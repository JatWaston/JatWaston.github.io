<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[编程时间]]></title>
  <subtitle><![CDATA[Write the code. Change the world.]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://jatwaston.github.io/"/>
  <updated>2015-05-25T03:11:35.000Z</updated>
  <id>http://jatwaston.github.io/</id>
  
  <author>
    <name><![CDATA[JatWaston]]></name>
    <email><![CDATA[support@jatwaston.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[使用locationd漏洞从sandbox内获取root权限]]></title>
    <link href="http://jatwaston.github.io/2015/05/25/locationd/"/>
    <id>http://jatwaston.github.io/2015/05/25/locationd/</id>
    <published>2015-05-25T02:10:50.000Z</published>
    <updated>2015-05-25T03:11:35.000Z</updated>
    <content type="html"><![CDATA[<h2 id="iOS沙盒机制">iOS沙盒机制</h2><p>　　iOS中的沙盒机制（SandBox）是一种安全体系，它规定了应用程序只能在为该应用创建的文件夹内读取文件，不可以访问其他地方的内容。所有的非代码文件都保存在这个地方，比如图片、声音、属性列表和文本文件等。<br><a id="more"></a><br>　　1.每个应用程序都在自己的沙盒内。<br><br>　　2.不能随意跨越自己的沙盒去访问别的应用程序沙盒的内容。<br><br>　　3.应用程序向外请求或接收数据都需要经过权限认证。<br><br>　　以上3点就是iOS沙盒机制的主要表现，一般来讲普通的用户级别app(从AppStore下载或者从其他第三方应用商店下载的ipa)很难越过iOS沙盒机制，除非有些特殊手段或者一些系统漏洞能利用，这里我们就来讲下<strong>越狱设备</strong>利用<code>locationd</code>漏洞来让ipa程序跳出沙盒来获取root权限。</p>
<h2 id="准备工作">准备工作</h2><p>1.删除<code>/var/mobile/Library/Preferences/com.apple.locationd.plist</code><br><br>2.软连接<code>/var/mobile/Library/Preferences/com.apple.locationd.plist</code>到需要权限的目录，比如<code>/Library/MobileSubstrate/DynamicLibraries</code><br><br>3.执行<code>CLClientShutdownDaemon()</code>来重启<code>locationd</code>服务,这是<code>/Library/MobileSubstrate/DynamicLibraries</code>目录权限将变为<code>mobile:mobile</code><br><br>4.编写<code>Tweak</code>来hook<code>locationd</code>,并将该<code>Tweak</code>拷贝到<code>/Library/MobileSubstrate/DynamicLibraries</code><br><br>5.再次调用<code>CLClientShutdownDaemon()</code>来重启<code>locationd</code>，这时<code>Tweak</code>也将随着<code>locationd</code>启动而启动，这时<code>Tweak</code>就可以用来做一些高权限的事情了，也就间接的让ipa获取到<code>root</code>权限了，完毕！<br><br>　　以上几点大体介绍了获取<code>root</code>权限要经历的步骤，该步骤在<code>iOS 7.x</code>系统上已验证成功，但是在<code>iOS 8.x</code>系统上第1步骤就失败了，所以<code>iOS 8.x</code>要换种方式实现，现在还在研究中，不过<code>腾讯手机管家Pro</code>已经实现了该功能，技术果然牛逼！废话不多说，先来看下代码如何实现吧!</p>
<h2 id="实现代码">实现代码</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)operator &#123;</span><br><span class="line">    <span class="built_in">NSFileManager</span> *fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">    <span class="built_in">NSString</span> * plistPath = <span class="string">@"/var/mobile/Library/Preferences/com.apple.locationd.plist"</span>;</span><br><span class="line">    <span class="built_in">NSString</span> * path2 = <span class="string">@"/Library/MobileSubstrate/DynamicLibraries"</span>;</span><br><span class="line">    <span class="built_in">NSError</span> * error = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> ([fileManager fileExistsAtPath:plistPath]) &#123;</span><br><span class="line">        [fileManager removeItemAtPath:plistPath error:&amp;error];</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">             <span class="built_in">NSLog</span>(<span class="string">@"error : %@"</span>, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [[<span class="built_in">NSFileManager</span> defaultManager] createSymbolicLinkAtPath:plistPath withDestinationPath:path2 error:&amp;error]; <span class="comment">//创建软链接到"/Library/MobileSubstrate/DynamicLibraries"</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (error != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"error : %@"</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">    CLClientShutdownDaemon(); <span class="comment">//重启locationd服务</span></span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(injectDylib) withObject:<span class="literal">nil</span> afterDelay:<span class="number">3.0</span>f]; <span class="comment">//延迟3s等待locationd服务启动</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)injectDylib &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSFileManager</span> *fileManage = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    [fileManage setAttributes:[<span class="built_in">NSDictionary</span> dictionaryWithObject:[<span class="built_in">NSNumber</span> numberWithUnsignedLong:<span class="number">0777</span>] forKey:NSFilePosixPermissions] ofItemAtPath:<span class="string">@"/Library/MobileSubstrate/DynamicLibraries/"</span> error:&amp;error];</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"NSFilePosixPermissions error:%@"</span>,[error localizedDescription]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *documents = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, <span class="literal">YES</span>) objectAtIndex:<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *zipPath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"Cappuccino.zip"</span> ofType:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *targetZipPath = [documents stringByAppendingPathComponent:<span class="string">@"Cappuccino.zip"</span>];</span><br><span class="line">    </span><br><span class="line">    [fileManage copyItemAtPath:zipPath toPath:targetZipPath error:&amp;error];</span><br><span class="line">    <span class="keyword">int</span> res = unZipMain((<span class="keyword">char</span>*)[targetZipPath UTF8String], (<span class="keyword">char</span>*)[documents UTF8String], <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *dylibFile = [documents stringByAppendingPathComponent:<span class="string">@"Cappuccino.dylib"</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *plistFile = [documents stringByAppendingPathComponent:<span class="string">@"Cappuccino.plist"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *targetDylibFile = <span class="string">@"/Library/MobileSubstrate/DynamicLibraries/Cappuccino.dylib"</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *targetPlistFile = <span class="string">@"/Library/MobileSubstrate/DynamicLibraries/Cappuccino.plist"</span>;</span><br><span class="line">    </span><br><span class="line">    [fileManage copyItemAtPath:plistFile toPath:targetPlistFile error:&amp;error];</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"plist error : %@"</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">    [fileManage copyItemAtPath:dylibFile toPath:targetDylibFile error:&amp;error];</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"dylib error : %@"</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">    CLClientShutdownDaemon(); <span class="comment">//重新启动locationd服务，以便启动插件服务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　以上代码中出现了<code>Cappuccino.dylib</code>和<code>Cappuccino.plist</code>，(<code>腾讯手机管家Pro</code>抱歉了，我抄袭了你的命名了!)这两个是用来hook<code>locationd</code>服务的插件，也是用来获取<code>root</code>权限的间接桥梁，它里面做的事情也很简单，就是简单的安装<code>deb</code>文件，其实也可以改成其他操作，比如注销，重启等操作，就看用户喜好了，虽然我没有详细的逆向<code>腾讯手机管家Pro</code>在<code>Cappuccino.dylib</code>写了什么样的代码，但是我大体也能猜出里面它其实是用来安装<code>deb</code>文件的，大体是下面这样的操作，<code>dpkg -i DEB_PATH</code>,<code>DEB_PATH</code>请根据需要自行改成自己<code>deb</code>所在的路径，如果你的<code>deb</code>是放在<code>ipa</code>的<code>Documents</code>的话，那也是可以根据<code>ipa的identifier</code>来获取，这里我就不实现了，<code>Cappuccino.dylib</code>和<code>Cappuccino.plist</code>的大体实现请看下图：<br><img src="http://7xijmx.com1.z0.glb.clouddn.com/10.49.09.png" alt="Cappuccino.dylib"><br><img src="http://7xijmx.com1.z0.glb.clouddn.com/10.48.57.png" alt="Cappuccino.plist"></p>
<h2 id="后记">后记</h2><p>　　到这里为止，我们就跳出了沙盒限制，获取到<code>root</code>权限了，不过以上方法只在<code>iOS 7.x</code>系统上测试过，<code>iOS 8.x</code>测试失败，（但是<code>腾讯手机管家Pro</code>实现了，还有待研究它是如何实现的）<code>iOS 6.x 和iOS 5.x</code>未测试（手头暂无机子)，如果读者感兴趣的话，可自行测试。</p>
<h2 id="参考">参考</h2><p><a href="http://bbs.iosre.com/t/locationd-sandbox-root/806" target="_blank" rel="external">iOS逆向论坛</a><br><br><a href="http://m.qq.com/?ADTAG=media.innerenter.gj.top" target="_blank" rel="external">腾讯手机管家Pro</a><br></p>
<p>　　</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="iOS沙盒机制">iOS沙盒机制</h2><p>　　iOS中的沙盒机制（SandBox）是一种安全体系，它规定了应用程序只能在为该应用创建的文件夹内读取文件，不可以访问其他地方的内容。所有的非代码文件都保存在这个地方，比如图片、声音、属性列表和文本文件等。<br/>]]>
    
    </summary>
    
      <category term="Tweaks" scheme="http://jatwaston.github.io/tags/Tweaks/"/>
    
      <category term="iOS安全" scheme="http://jatwaston.github.io/categories/iOS%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于Xcode的Other Linker Flags]]></title>
    <link href="http://jatwaston.github.io/2015/05/11/Other-Linker-Flags/"/>
    <id>http://jatwaston.github.io/2015/05/11/Other-Linker-Flags/</id>
    <published>2015-05-11T03:19:44.000Z</published>
    <updated>2015-05-11T03:35:09.000Z</updated>
    <content type="html"><![CDATA[<p>转自：<a href="http://blog.csdn.net/meegomeego/article/details/19343423" target="_blank" rel="external">http://blog.csdn.net/meegomeego/article/details/19343423</a><br><a id="more"></a></p>
<h2 id="背景">背景</h2><p>在ios开发过程中，有时候会用到第三方的静态库(.a文件)，然后导入后发现编译正常但运行时会出现<code>selector not recognized</code>的错误，从而导致app闪退。接着仔细阅读库文件的说明文档，你可能会在文档中发现诸如在<code>Other Linker Flags</code>中加入-<code>ObjC</code>或者<code>-all_load</code>这样的解决方法。<br>那么，<code>Other Linker Flags</code>到底是用来干什么的呢？还有<code>-ObjC</code>和<code>-all_load</code>到底发挥了什么作用呢？</p>
<h2 id="链接器">链接器</h2><p>首先，要说明一下<code>Other Linker Flags</code>到底是用来干嘛的。说白了，就是<code>ld</code>命令除了默认参数外的其他参数。<code>ld</code>命令实现的是链接器的工作，详细说明可以在终端<code>man ld</code>查看。<br>如果有人不清楚链接器是什么东西的话，我可以作个简单的说明。<br>一个程序从简单易读的代码到可执行文件往往要经历以下步骤：</p>
<p><blockquote class="blockquote-left">源代码 &gt; 预处理器 &gt; 编译器 &gt; 汇编器 &gt; 机器码 &gt; 链接器 &gt; 可执行文件 </blockquote><br>源文件经过一系列处理以后，会生成对应的<code>.obj</code>文件，然后一个项目必然会有许多<code>.obj</code>文件，并且这些文件之间会有各种各样的联系，例如函数调用。链接器做的事就是把这些目标文件和所用的一些库链接在一起形成一个完整的可执行文件。<br>可能我描述的比较肤浅，因为我自己了解的也不是很深，建议大家读一下这篇文章，可以对链接器做的事情有个大概的了解：<a href="http://www.dutor.net/index.php/2012/02/what-linkers-do/" target="_blank" rel="external">链接器做了什么</a></p>
<h2 id="为什么会闪退">为什么会闪退</h2><p>苹果官方Q&amp;A上有这么一段话：</p>
<p><blockquote class="blockquote-left">The “selector not recognized” runtime exception occurs due to an issue between the implementation of standard UNIX static libraries, the linker and the dynamic nature of Objective-C. Objective-C does not define linker symbols for each function (or method, in Objective-C) - instead, linker symbols are only generated for each class. If you extend a pre-existing class with categories, the linker does not know to associate the object code of the core class implementation and the category implementation. This prevents objects created in the resulting application from responding to a selector that is defined in the category. </blockquote><br>翻译过来，大概意思就是<code>Objective-C</code>的链接器并不会为每个方法建立符号表，而是仅仅为类建立了符号表。这样的话，如果静态库中定义了已存在的一个类的分类，链接器就会以为这个类已经存在，不会把分类和核心类的代码合起来。这样的话，在最后的可执行文件中，就会缺少分类里的代码，这样函数调用就失败了。</p>
<h2 id="解决方法">解决方法</h2><p>解决方法在背景那块我就提到了，就是在Other Linker Flags里加上所需的参数，用到的参数一般有以下3个：<br><code>-ObjC</code>,<code>-all_load</code>,<code>-force_load</code><br>下面来说说每个参数存在的意义和具体做的事情。<br>首先是<code>-ObjC</code>，一般这个参数足够解决前面提到的问题，苹果官方说明如下：</p>
<p><blockquote class="blockquote-left">This flag causes the linker to load every object file in the library that defines an Objective-C class or category. While this option will typically result in a larger executable (due to additional object code loaded into the application), it will allow the successful creation of effective Objective-C static libraries that contain categories on existing classes.</blockquote><br>简单说来，加了这个参数后，链接器就会把静态库中所有的<code>Objective-C</code>类和分类都加载到最后的可执行文件中，虽然这样可能会因为加载了很多不必要的文件而导致可执行文件变大，但是这个参数很好地解决了我们所遇到的问题。但是事实真的是这样的吗？<br><br>如果<code>-ObjC</code>参数真的这么有效，那么事情就会简单多了。</p>
<p><blockquote class="blockquote-left">Important: For 64-bit and iPhone OS applications, there is a linker bug that prevents -ObjC from loading objects files from static libraries that contain only categories and no classes. The workaround is to use the -allload or -forceload flags.</blockquote><br>当静态库中只有分类而没有类的时候，<code>-ObjC</code>参数就会失效了。这时候，就需要使用<code>-all_load</code>或者<code>-force_load</code>了。<br></p>
<p><code>-all_load</code>会让链接器把所有找到的目标文件都加载到可执行文件中，但是千万不要随便使用这个参数！假如你使用了不止一个静态库文件，然后又使用了这个参数，那么你很有可能会遇到<code>ld: duplicate symbol</code>错误，因为不同的库文件里面可能会有相同的目标文件，所以建议在遇到<code>-ObjC</code>失效的情况下使用<code>-force_load</code>参数。</p>
<p><code>-force_load</code>所做的事情跟<code>-all_load</code>其实是一样的，但是<code>-force_load</code>需要指定要进行全部加载的库文件的路径，这样的话，你就只是完全加载了一个库文件，不影响其余库文件的按需加载。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>转自：<a href="http://blog.csdn.net/meegomeego/article/details/19343423">http://blog.csdn.net/meegomeego/article/details/19343423</a><br>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://jatwaston.github.io/tags/iOS/"/>
    
      <category term="转载" scheme="http://jatwaston.github.io/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="iOS开发" scheme="http://jatwaston.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何hook那些在IDA中显示为sub_xxx的函数]]></title>
    <link href="http://jatwaston.github.io/2015/05/06/hook-sub-xxx-functions-in-IDA/"/>
    <id>http://jatwaston.github.io/2015/05/06/hook-sub-xxx-functions-in-IDA/</id>
    <published>2015-05-06T08:54:23.000Z</published>
    <updated>2015-05-06T10:57:36.000Z</updated>
    <content type="html"><![CDATA[<p>转自：<a href="http://www.iosre.com/t/hook-ida-sub-xxx/720" target="_blank" rel="external">http://www.iosre.com/t/hook-ida-sub-xxx/720</a></p>
<p>唉，说起来这就是一个坑，Cydia Substrate在其文档中也没找到详细说明，最后也只能来看看代码曾半仙最早给的那份substrate-master源码，然后一切就了然于胸了，这个坑很大，很大！！！<br>现在我们先来看下MSHookFunction怎么Hook IDA中的sub_xxxx函数，然后再来谈谈为啥是这样的。<a id="more"></a><br><img src="http://7xijmx.com1.z0.glb.clouddn.com/645a3bc22fb63bec.jpg" alt=""><br>就以这段代码为例吧，下断点红色选中部分，中的sub_17C94就是我想要Hook的函数，首先确认了下参数个数为2个。<br>以下给出代码片段截图：<br><img src="http://7xijmx.com1.z0.glb.clouddn.com/a23609255bcca09b.png" alt=""><br>看到这里我想很多人有点不理解，为啥需要 | 0x00000001，别急，下面我就借花献佛，慢慢道来也。<br>既然源头是出现在MSHookFunction上，那们我们就去阅读下这块的代码:<br><img src="http://7xijmx.com1.z0.glb.clouddn.com/0c8609977fa3bbc4.jpg" alt=""><br><img src="http://7xijmx.com1.z0.glb.clouddn.com/a25d0b61f1a8edcd.jpg" alt=""><br>从这2 段代码中可以很明显的看到在SubstrateHookFunction中，看到这么一句<br><code>if ((reinterpret_cast(symbol) &amp; 0x1) == 0)</code><br>也就是说，MSHookFunction在判断Hook函数的时候，是通过在传到进来函数地址的奇偶数来判断是ARM指令的函数，还是Thumb指令的函数。<br>这个坑好大，我勒个去啊！！！<br>别急，接下来看这句<br><code>reinterpret_cast(reinterpret_cast(symbol) &amp; ~0x1)</code><br>判断完后，为了能正确Hook地址，又改回原来的地址了，这下变清楚了吧。<br>再者，从MSFindSymbol函数中也能清楚的看到<strong>value |= 0x00000001</strong>这句！！！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>转自：<a href="http://www.iosre.com/t/hook-ida-sub-xxx/720">http://www.iosre.com/t/hook-ida-sub-xxx/720</a></p>
<p>唉，说起来这就是一个坑，Cydia Substrate在其文档中也没找到详细说明，最后也只能来看看代码曾半仙最早给的那份substrate-master源码，然后一切就了然于胸了，这个坑很大，很大！！！<br>现在我们先来看下MSHookFunction怎么Hook IDA中的sub_xxxx函数，然后再来谈谈为啥是这样的。]]>
    
    </summary>
    
      <category term="Tweaks" scheme="http://jatwaston.github.io/tags/Tweaks/"/>
    
      <category term="转载" scheme="http://jatwaston.github.io/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="iOS安全" scheme="http://jatwaston.github.io/categories/iOS%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[objc_msgSend()报错Too many arguments to function call ,expected 0,have 3]]></title>
    <link href="http://jatwaston.github.io/2015/05/04/objc-msgSend-error/"/>
    <id>http://jatwaston.github.io/2015/05/04/objc-msgSend-error/</id>
    <published>2015-05-04T07:13:21.000Z</published>
    <updated>2015-05-04T07:16:02.000Z</updated>
    <content type="html"><![CDATA[<p>解决方式：<br><code>Build Setting--&gt; Apple LLVM 6.0 - Preprocessing--&gt; Enable Strict Checking of objc_msgSend Calls</code>  改为 NO</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>解决方式：<br><code>Build Setting--&gt; Apple LLVM 6.0 - Preprocessing--&gt; Enable Strict Checking of objc_msgSend Calls</code>  改为 NO</p>
]]>
    </summary>
    
      <category term="Xcode" scheme="http://jatwaston.github.io/tags/Xcode/"/>
    
      <category term="iOS" scheme="http://jatwaston.github.io/tags/iOS/"/>
    
      <category term="iOS开发" scheme="http://jatwaston.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python爬虫学习（三）]]></title>
    <link href="http://jatwaston.github.io/2015/04/27/Python-Spider-3/"/>
    <id>http://jatwaston.github.io/2015/04/27/Python-Spider-3/</id>
    <published>2015-04-27T08:46:15.000Z</published>
    <updated>2015-05-08T09:34:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="回顾">回顾</h2><p>　　上一次我们编写了获取淘宝MM的图片，主要用到了模拟post请求，获取数据，然后json解析，正则匹配，图片保存等内容，虽然我们最后获取到了淘宝MM的图片，但是由于防盗刷机制，我们不能大面积的去获取图片，大面积的获取图片的时候，会要求我们登录，这次我们就来模拟下登录，到时再完善下上次获取淘宝MM的代码。<a id="more"></a></p>
<h2 id="模拟登陆">模拟登陆</h2><p>　　要模拟登陆，首先你要知道登陆的URL是什么，这个好办，可以通过Fiddler来获取请求登陆的URL以及POST给服务端的数据，（如果不知道如何使用Fiddler，麻烦移步<a href="http://www.cnblogs.com/TankXiao/archive/2012/02/06/2337728.html" target="_blank" rel="external">这里</a>，介绍的已经够清楚了）接下来我们就来模拟登陆下，这次模拟登陆的网站是<a href="http://www.imooc.com/" target="_blank" rel="external">慕课网</a>,(为什么选它而不选淘宝呢？因为它比较好模拟！淘宝太复杂了，我还不会模拟！）当我们登陆慕课网的时候，我们通过Fiddler我们会看到有两个请求：<br><img src="http://7xijmx.com1.z0.glb.clouddn.com/2.jpg" alt=""><br>一个是登陆的URL，一个是我的课程，登陆成功后，会跳着到我的课程，接下来我们再来看看登陆的URL具体POST了什么数据给服务端，经过查看我们能看到下面的POST内容：<br><img src="http://7xijmx.com1.z0.glb.clouddn.com/1.jpg" alt=""><br>主要是传递了<code>username</code>,<code>password</code>,<code>remember</code>,这3个字段我相信大家都明白是什么意思，可是有一点应该批评下慕课的开发人员，<strong>为什么<code>password</code>传递的值是密码明文啊？你不知道这样很危险吗？</strong>这个我们就先不管了,我们先来看下如何模拟吧，先上代码吧！</p>
<h2 id="实现过程">实现过程</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line">__author__ = <span class="string">'JatWaston'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> cookielib</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MOOC</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		self.loginUrl = <span class="string">'http://www.imooc.com/user/login'</span></span><br><span class="line">		self.cookies = cookielib.CookieJar()</span><br><span class="line">		self.postdata = urllib.urlencode(&#123;</span><br><span class="line">			<span class="string">'username'</span>:<span class="string">'xxxxx'</span>, <span class="comment">#用户名请自行修改</span></span><br><span class="line">			<span class="string">'password'</span>:<span class="string">'xxxxx'</span>, <span class="comment">#密码请自行修改</span></span><br><span class="line">			<span class="string">'remember'</span>:<span class="string">'1'</span></span><br><span class="line">			&#125;)</span><br><span class="line">		self.courseUrl = <span class="string">'http://www.imooc.com/space/index'</span><span class="comment">#我的课程</span></span><br><span class="line">		self.opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(self.cookies)) <span class="comment">#</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(self)</span>:</span></span><br><span class="line">		request = urllib2.Request(url=self.loginUrl,data=self.postdata)</span><br><span class="line">		result = self.opener.open(request)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">getCourse</span><span class="params">(self)</span>:</span></span><br><span class="line">		request = urllib2.Request(self.courseUrl)</span><br><span class="line">		result = self.opener.open(request)</span><br><span class="line">		<span class="keyword">print</span> result.read()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">	imooc = MOOC()</span><br><span class="line">	imooc.login()</span><br><span class="line">	imooc.getCourse()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	main()</span><br></pre></td></tr></table></figure>
<p>由于<code>urllib2.urlopen()</code>函数不支持验证、cookie或者其它HTTP高级功能。要支持这些功能，必须使用<code>build_opener()</code>函数创建自定义Opener对象。<br><code>build_opener([handler1 [ handler2, ... ]])</code></p>
<p><blockquote class="blockquote-left">参数handler是Handler实例，常用的有HTTPBasicAuthHandler、HTTPCookieProcessor、ProxyHandler等。<br>build_opener ()返回的对象具有open()方法，与urlopen()函数的功能相同。</blockquote><br>如果想详细了解<code>build_opener</code>用法，可以查看这个<a href="http://www.jb51.net/article/46495.htm" target="_blank" rel="external">教程</a>，介绍的也挺清楚的。</p>
<h2 id="后记">后记</h2><p>　　通过以上代码我们就能模拟登陆慕课了，后续我会完善淘宝MM的抓取，代码已经上传到Github了，大家可以到<a href="https://github.com/JatWaston/PySpider/tree/master/PySpider/Mooc" target="_blank" rel="external">这里</a>下载。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="回顾">回顾</h2><p>　　上一次我们编写了获取淘宝MM的图片，主要用到了模拟post请求，获取数据，然后json解析，正则匹配，图片保存等内容，虽然我们最后获取到了淘宝MM的图片，但是由于防盗刷机制，我们不能大面积的去获取图片，大面积的获取图片的时候，会要求我们登录，这次我们就来模拟下登录，到时再完善下上次获取淘宝MM的代码。]]>
    
    </summary>
    
      <category term="Python" scheme="http://jatwaston.github.io/tags/Python/"/>
    
      <category term="Python开发" scheme="http://jatwaston.github.io/categories/Python%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python爬虫学习（二）]]></title>
    <link href="http://jatwaston.github.io/2015/04/25/Python-Spider-2/"/>
    <id>http://jatwaston.github.io/2015/04/25/Python-Spider-2/</id>
    <published>2015-04-25T02:08:59.000Z</published>
    <updated>2015-04-27T08:38:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="回顾">回顾</h2><p>　　上一次我们编写了一个最简单的勉强称的上爬虫的<a href="http://jatwaston.github.io/2015/04/25/Python-Spider-1/" target="_blank" rel="external">代码</a>，基本上什么事情都没做，只是简单的获取了百度的首页内容，离我们想要的真正爬虫还差远了，今天我们就来进阶一下吧，把获取回来的网页内容进行解析，获取自己想要内容，开始吧，骚年！<br>　　<a id="more"></a></p>
<h2 id="如何解析网页内容">如何解析网页内容</h2><h3 id="通过字符串直接解析">通过字符串直接解析</h3><p>　　我们知道通过urllib2获取回来的网页内容是字符串，那我们就可以直接使用Python里面字符串的api进行拆分，解析，来获取我们想要的内容，虽然这种方式效率比较低下，但也不失为一种方式，不过我们今天不讲这种方法，我们来讲正则表达式。</p>
<h3 id="通过正则表达式">通过正则表达式</h3><p>　　何为正则表达式呢？大百度的解释是:</p>
<p><blockquote class="blockquote-center">正则表达式，又称正规表示法、常规表示法（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本。</blockquote><br>今天我们讲解的重点内容也不是如何编写正则表达式来匹配我们想要的内容，网络上已经有很多讲解如何编写正则表达式了，如果大家想了解的，可以直接查看该<a href="http://www.cnblogs.com/huxi/archive/2010/07/04/1771073.html" target="_blank" rel="external">链接</a>，解释的很清楚了，我这边就不啰嗦了，我倡导拿来主义，直接上手项目来学习正则表达式，边做项目边学，开搞吧！</p>
<h2 id="获取淘宝MM的照片和资料">获取淘宝MM的照片和资料</h2><p>　　都说程序猿无妹子，那么今天我们就来获取一些妹子的资料，嘿嘿！<br>　　<img src="http://7xijmx.com1.z0.glb.clouddn.com/1.png" alt=""></p>
<h3 id="获取淘宝MM网站内容">获取淘宝MM网站内容</h3><p><code>taobaoMM.py</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*-coding:utf-8-*-</span></span><br><span class="line"><span class="keyword">import</span> urllib2 <span class="comment">#引入python自带的urllib2库</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetchWebPage</span><span class="params">(url)</span>:</span></span><br><span class="line">	request = urllib2.Request(url)</span><br><span class="line">	<span class="comment">#伪造UA</span></span><br><span class="line">	request.add_header(<span class="string">'User-Agent'</span>, <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.118 Safari/537.36'</span>)</span><br><span class="line">	response = urllib2.urlopen(request)</span><br><span class="line">	details = response.read().decode(<span class="string">"gbk"</span>).encode(<span class="string">"utf-8"</span>) <span class="comment">#gbk转换为utf-8</span></span><br><span class="line">	<span class="keyword">return</span> details; <span class="comment">#返回结果</span></span><br><span class="line"></span><br><span class="line">htmlContent = fetchWebPage(<span class="string">"http://mm.taobao.com/search_tstar_model.htm"</span>)</span><br><span class="line"><span class="keyword">print</span> htmlContent</span><br></pre></td></tr></table></figure>
<h3 id="查看网页源码，找到自己感兴趣的内容">查看网页源码，找到自己感兴趣的内容</h3><p>　　打开<a href="http://mm.taobao.com/search_tstar_model.htm" target="_blank" rel="external">淘宝MM</a>的链接，通过Chrome开发者工具我们会看到如下内容：<br>　　<img src="http://7xijmx.com1.z0.glb.clouddn.com/mm1.png" alt=""><br>接下来我们再深入进去查看淘宝MM所在的标签，最后我们定位到下面这个标签<br><img src="http://7xijmx.com1.z0.glb.clouddn.com/mm4.png" alt=""><br>好了，前期准备工作结束，下面开始具体的解析编码阶段，想想还有点小激动呢！<br><img src="http://7xijmx.com1.z0.glb.clouddn.com/1.png" alt=""></p>
<h3 id="解析内容">解析内容</h3><p>　　原以为通过以上的<code>taobaoMM.py</code>代码可以获取到网页的所有内容，可惜的是淘宝MM所在标签是通过动态从服务器后台获取的，使用上面的代码获取出来的结果如下：<br>　　<img src="http://7xijmx.com1.z0.glb.clouddn.com/屏幕快照 2015-04-25 下午5.52.40.png" alt=""><br>看到没有，淘宝MM所在的标签竟然是空的，它竟是空的！这叫我如何是好啊，不过不用担心，我们还有Chrome开发利器，通过它我们来看看这些是如何从后台获取到数据进行填充的。<br>最后查看到的请求如下：<br><img src="http://7xijmx.com1.z0.glb.clouddn.com/5.59.58.png" alt=""><br><img src="http://7xijmx.com1.z0.glb.clouddn.com/6.00.22.png" alt=""><br>其实它是发出了一个post请求，请求的url为<code>http://mm.taobao.com/tstar/search/tstar_model.do?_input_charset=utf-8</code>,post的数据为<br><img src="http://7xijmx.com1.z0.glb.clouddn.com/6.05.17.png" alt=""><br>这下我们就更简单了，直接发个post请求，带上需要填充的数据，对返回的json直接解析就好了，开工吧！<br><code>taobaoMM.py</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*-coding:utf-8-*-</span></span><br><span class="line"><span class="keyword">import</span> urllib2 <span class="comment">#引入python自带的urllib2库</span></span><br><span class="line"><span class="keyword">import</span> urllib <span class="comment">#引入python自带的urllib库</span></span><br><span class="line"><span class="keyword">import</span> json <span class="comment">#解析json使用</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">url = <span class="string">'http://mm.taobao.com/tstar/search/tstar_model.do?_input_charset=utf-8'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetchWebPage</span><span class="params">(url)</span>:</span></span><br><span class="line">	request = urllib2.Request(url)</span><br><span class="line">	<span class="comment">#伪造UA</span></span><br><span class="line">	request.add_header(<span class="string">'User-Agent'</span>, <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.118 Safari/537.36'</span>)</span><br><span class="line">	response = urllib2.urlopen(request)</span><br><span class="line">	details = response.read().decode(<span class="string">"gbk"</span>).encode(<span class="string">"utf-8"</span>) <span class="comment">#gbk转换为utf-8</span></span><br><span class="line">	<span class="keyword">return</span> details; <span class="comment">#返回结果</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postRequest</span><span class="params">(url,values)</span>:</span></span><br><span class="line">	data = urllib.urlencode(values)</span><br><span class="line">	request = urllib2.Request(url,data)</span><br><span class="line">	response = urllib2.urlopen(request)</span><br><span class="line">	json = response.read().decode(<span class="string">"gbk"</span>).encode(<span class="string">"utf-8"</span>) <span class="comment">#gbk转换为utf-8</span></span><br><span class="line">	<span class="keyword">return</span> json; <span class="comment">#返回结果</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">saveImage</span><span class="params">(imageURL,fileName)</span>:</span></span><br><span class="line">	response = urllib2.urlopen(imageURL)</span><br><span class="line">	imageData = response.read()</span><br><span class="line">	f = open(fileName,<span class="string">'wb'</span>)</span><br><span class="line">	f.write(imageData)</span><br><span class="line">	f.close()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mkdir</span><span class="params">(path)</span>:</span></span><br><span class="line">	path = path.strip()</span><br><span class="line">	isExist = os.path.exists(path)</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> isExist:</span><br><span class="line">		os.mkdir(path)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># htmlContent = fetchWebPage("http://mm.taobao.com/search_tstar_model.htm")</span></span><br><span class="line">values = &#123;<span class="string">'viewFlag'</span>:<span class="string">'A'</span>,<span class="string">'sortType'</span>:<span class="string">'default'</span>,<span class="string">'currentPage'</span>:<span class="string">'1'</span>,<span class="string">'pageSize'</span>:<span class="string">'100'</span>&#125;</span><br><span class="line">jsonData = postRequest(url,values)</span><br><span class="line">jsonDic = json.loads(jsonData)</span><br><span class="line">contentList = jsonDic[<span class="string">'data'</span>][<span class="string">'searchDOList'</span>];</span><br><span class="line"><span class="comment"># count = count(jsonDic['data']['searchDOList'])</span></span><br><span class="line"><span class="comment"># mkdir("Images")</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> contentList:</span><br><span class="line">	<span class="comment"># mkdir(item['realName'])</span></span><br><span class="line">	filePath = <span class="string">"Images"</span> + <span class="string">"/"</span> + item[<span class="string">'realName'</span>];</span><br><span class="line">	mkdir(filePath)</span><br><span class="line">	fileName = filePath + <span class="string">"/avatar.jpg"</span>;</span><br><span class="line">	saveImage(item[<span class="string">'avatarUrl'</span>],fileName)</span><br></pre></td></tr></table></figure>
<p>这样我们就可以获取到淘宝MM的封面图了，接下来我们再来获取单个淘宝MM详情页的图片，这个时候就需要用到正则表达式来匹配内容了，首先先通过Chrome开发者工具来查看详情页的标签，定位到想要获取图片的标签，如图所示：<br><img src="http://7xijmx.com1.z0.glb.clouddn.com/4.23.55.png" alt=""><br>最后定位的标签格式大致如此<br><code>&lt;img style=&quot;float: none;margin: 10.0px;&quot; src=&quot;http://img03.taobaocdn.com/imgextra/i3/745790526/T2qKS4XAxaXXXXXXXX_!!745790526.jpg&quot;&gt;</code><br>src后面就是我们想要的图片了，编写的获取图片代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detailImages</span><span class="params">(url)</span>:</span></span><br><span class="line">	<span class="keyword">print</span> url</span><br><span class="line">	content = fetchWebPage(url)</span><br><span class="line">	pattern = re.compile(<span class="string">'&lt;img style="float: none;margin: 10.0px;" src="(.*?)"/&gt;'</span>) <span class="comment">#正则匹配</span></span><br><span class="line">	items = re.findall(pattern,content);</span><br><span class="line">	<span class="keyword">return</span> items;</span><br></pre></td></tr></table></figure>
<p>大功告成了！不过这边有个问题，就是淘宝MM的详情页有防盗刷的机制，好像多请求几次后会要求用户登录，这个问题我们下次讲模拟登录的时候再来处理，我这次为了防止登录所以只采集了一个页面的图片数据，还不会要求我登录。</p>
<h3 id="存起来，慢慢欣赏">存起来，慢慢欣赏</h3><p>最后保存的结果如下：<br><img src="http://7xijmx.com1.z0.glb.clouddn.com/4.37.12.png" alt=""><br>这样我们就拿到了封面图和详情页面的所有图片了。</p>
<h2 id="后记">后记</h2><p>　　这次本以为需要用到正则来处理网页的结果，可惜爬取回来的网页竟然不包含动态的内容，所以只能另外寻找方法，最后却直接找到api来直接显示结果，发个post请求直接返回json，也算是很方便了，代码也已上传到Github上了，大家可以直接从<a href="https://github.com/JatWaston/PySpider/tree/master/PySpider/TaobaoMM" target="_blank" rel="external">这里</a>下载。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="回顾">回顾</h2><p>　　上一次我们编写了一个最简单的勉强称的上爬虫的<a href="http://jatwaston.github.io/2015/04/25/Python-Spider-1/">代码</a>，基本上什么事情都没做，只是简单的获取了百度的首页内容，离我们想要的真正爬虫还差远了，今天我们就来进阶一下吧，把获取回来的网页内容进行解析，获取自己想要内容，开始吧，骚年！<br>]]>
    
    </summary>
    
      <category term="Python" scheme="http://jatwaston.github.io/tags/Python/"/>
    
      <category term="Python开发" scheme="http://jatwaston.github.io/categories/Python%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python爬虫学习（一）]]></title>
    <link href="http://jatwaston.github.io/2015/04/25/Python-Spider-1/"/>
    <id>http://jatwaston.github.io/2015/04/25/Python-Spider-1/</id>
    <published>2015-04-24T23:29:54.000Z</published>
    <updated>2015-04-26T05:17:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前记">前记</h2><p>　　一直从事于iOS开发多年，所接触的大部分都是客户端的开发，处理服务端的数据，逻辑处理，然后展示给用户，其实一直以来对服务端的开发还是比较感兴趣的，本着编程语言是相通的想法，所以业余时间就学了点服务端的开发，接触过PHP和Python,总感觉Python学起来会容易点（PHPer不要喷我啊，这只是小弟的想法，不要做语言攻击啊），而且最近自己也在学习Python爬虫，所以就纯当纪录下自己学习Python的笔记了，因为小弟属于刚学习阶段，能力有限，如果有说错的地方，欢迎指出。<a id="more"></a>
　　</p>
<h2 id="什么是Python爬虫">什么是Python爬虫</h2><p>　　底下这段话是百度百科对网络爬虫的解释<br>　　<blockquote class="blockquote-center">网络爬虫（又被称为网页蜘蛛，网络机器人，在FOAF社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动的抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁，自动索引，模拟程序或者蠕虫。</blockquote><br>　　<br>　　其实说简单点就是一段自动化执行的程序，用来在网络上爬取你想要的内容，最出名的网络爬虫应用算是google的网络爬虫和百度的网络爬虫了，他们每天都要爬取网络上海量的数据，bla bla bla爬取数据，然后再做数据分析处理，然后通过搜索展示给我们，可以说网络爬虫是搜索引擎的根基。<br>　　今天我要讲的网络爬虫肯定没有那么搜索引擎所用的爬虫那么高深，毕竟我只是个初学者，而且还是个学渣啊<img src="http://7xijmx.com1.z0.glb.clouddn.com/20130703155605_CYHZQ.thumb.600_0.jpeg" alt="">，掩面而过啊，但是我相信复杂的东西其实都是由很多简单的东西构成的，所以今天就来讲下最简单的网络爬虫，走起！</p>
<h2 id="编写你的第一个网络爬虫">编写你的第一个网络爬虫</h2><p>　　看了上面这么多废话，相信你也烦了，那我们直接开始吧，在开始之前我再废话一句啊（博主，你够了，信不信我拿刀砍死你啊，<img src="http://7xijmx.com1.z0.glb.clouddn.com/20130703155605_CYHZQ.thumb.600_0.jpeg" alt="">），保证是最后一句了，就是小弟用的Python是<strong>2.7</strong>系列的，Python 3系列的听说改动较多，如果代码无法运行，请先检查你的Python版本。<br>而且运行系统是<strong>Mac</strong>,Windows下如果无法运行我暂时也解决不了，因为我已经好几年没在Windows下写程序了，哈哈哈！<br>　　<blockquote class="blockquote-center">Talk is cheap. Show me the code.<br>　　Linus Torvalds</blockquote><br>翠花，上酸菜，不，上代码！<br><code>baidu.py</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8 </span></span><br><span class="line"><span class="keyword">import</span> urllib2 <span class="comment">#引入python自带的urllib2库</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetchWebPage</span><span class="params">(url)</span>:</span></span><br><span class="line">	page = urllib2.urlopen(url); <span class="comment">#打开url链接</span></span><br><span class="line">	html = page.read() <span class="comment">#读取网页内容</span></span><br><span class="line">	<span class="keyword">return</span> html; <span class="comment">#返回结果</span></span><br><span class="line"></span><br><span class="line">htmlContent = fetchWebPage(<span class="string">"http://www.baidu.com/"</span>)</span><br><span class="line"><span class="keyword">print</span> htmlContent</span><br></pre></td></tr></table></figure>
<p>代码已经写的够简单了，相信大家都看的懂了，我就不废话了，希望大家有机会的话也去敲敲代码实现下。下一次将为大家讲解下从爬取回来的网页中获取自己想要的内容。</p>
<p>　　
　　
　　</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前记">前记</h2><p>　　一直从事于iOS开发多年，所接触的大部分都是客户端的开发，处理服务端的数据，逻辑处理，然后展示给用户，其实一直以来对服务端的开发还是比较感兴趣的，本着编程语言是相通的想法，所以业余时间就学了点服务端的开发，接触过PHP和Python,总感觉Python学起来会容易点（PHPer不要喷我啊，这只是小弟的想法，不要做语言攻击啊），而且最近自己也在学习Python爬虫，所以就纯当纪录下自己学习Python的笔记了，因为小弟属于刚学习阶段，能力有限，如果有说错的地方，欢迎指出。]]>
    
    </summary>
    
      <category term="Python" scheme="http://jatwaston.github.io/tags/Python/"/>
    
      <category term="Python开发" scheme="http://jatwaston.github.io/categories/Python%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS Crash文件的解析]]></title>
    <link href="http://jatwaston.github.io/2015/04/24/iOS-Crash/"/>
    <id>http://jatwaston.github.io/2015/04/24/iOS-Crash/</id>
    <published>2015-04-24T02:29:55.000Z</published>
    <updated>2015-04-24T04:46:58.000Z</updated>
    <content type="html"><![CDATA[<p>转载自：<a href="http://www.cnblogs.com/smileEvday/p/Crash1.html" target="_blank" rel="external">http://www.cnblogs.com/smileEvday/p/Crash1.html</a></p>
<p>　　开发程序的过程中不管我们已经如何小心，总是会在不经意间遇到程序闪退。脑补一下当你在一群人面前自信的拿着你的App做功能预演的时候，流畅的操作被无情地Crash打断。联想起老罗在发布Smartisan OS的时候说了，他准备了10个手机，如果一台有问题，就换一台，如果10台后挂了他就不做手机了。好了不闲扯了，今天就跟大家一起聊聊iOSCrash文件的组成以及常用的分析工具。</p>
<p>　　有一个WWDC 2010的视频推荐大家抽空看看，视频名称<a href="https://developer.apple.com/videos/wwdc/2010/?id=317" target="_blank" rel="external">“Understanding Crash Reports on iPhone OS”</a>，该视频详细讲解了Crash文件的结构。当然如果你没时间看的话，不妨阅读以下这篇文章。<br>　　<a id="more"></a></p>
<h2 id="Crash文件结构">Crash文件结构</h2><p>当程序运行Crash的时候，系统会把运行的最后时刻的运行信息记录下来，存储到一个文件中，也就是我们所说的Crash文件。iOS的Crash日志通常由以下6各部分组成。</p>
<h3 id="Process_Information(进程信息)">Process Information(进程信息)</h3><p><img src="http://images.cnitblog.com/blog/302680/201412/230718553901251.png" alt=""></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Incident Idnetifier</td>
<td>崩溃报告的唯一标识符，不同的Crash</td>
</tr>
<tr>
<td>CrashReporter Key</td>
<td>设备标识相对应的唯一键值(并非真正的设备的UDID，苹果为了保护用户隐私iOS6以后已经无法获取)。通常同一个设备上同一版本的App发生Crash时，该值都是一样的。</td>
</tr>
<tr>
<td>Hardware Model</td>
<td>代表发生Crash的设备类型，上图中的“iPad4,4”代表iPad Air</td>
</tr>
<tr>
<td>Process</td>
<td>代表Crash的进程名称，通常都是我们的App的名字, []里面是当时进程的ID</td>
</tr>
<tr>
<td>Path</td>
<td>可执行程序在手机上的存储位置，注意路径时到XXX.app/XXX，XXX.app其实是作为一个Bundle的，真正的可执行文件其实是Bundle里面的XXX，感兴趣的可以自己查一下相关资料，有机会我后面也会介绍到</td>
</tr>
<tr>
<td>Identifier</td>
<td>你的App的Indentifier，通常为“com.xxx.yyy”，xxx代表你们公司的域名，yyy代表某一个App</td>
</tr>
<tr>
<td>Version</td>
<td>当前App的版本号，由Info.plist中的两个字段组成，CFBundleShortVersionString and CFBundleVersion</td>
</tr>
<tr>
<td>Code Type</td>
<td>当前App的CPU架构</td>
</tr>
<tr>
<td>Parent Process</td>
<td>当前进程的父进程，由于iOS中App通常都是单进程的，一般父进程都是launchd</td>
</tr>
</tbody>
</table>
<h3 id="Basic_Information">Basic Information</h3><p><img src="http://images.cnitblog.com/blog/302680/201501/052025393435295.png" alt=""></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Date/Time</td>
<td>Crash发生的时间，可读的字符串</td>
</tr>
<tr>
<td>OS Version</td>
<td>系统版本，（）内的数字代表的时Bulid号</td>
</tr>
<tr>
<td>Report Version</td>
<td>Crash日志的格式，目前基本上都是104，不同的version里面包含的字段可能有不同</td>
</tr>
</tbody>
</table>
<h3 id="Exception（非常重要）">Exception（非常重要）</h3><p><img src="http://images.cnitblog.com/blog/302680/201501/052029230317758.png" alt=""></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Exception Type</td>
<td>异常类型</td>
</tr>
<tr>
<td>Exception Subtype</td>
<td>异常子类型</td>
</tr>
<tr>
<td>Crashed Thread</td>
<td>发生异常的线程号</td>
</tr>
</tbody>
</table>
<h3 id="Thread_Backtrace">Thread Backtrace</h3><p><img src="http://images.cnitblog.com/blog/302680/201501/052034366876268.png" alt=""><br>发生Crash的线程的Crash调用栈，从上到下分别代表调用顺序，最上面的一个表示抛出异常的位置，依次往下可以看到API的调用顺序。上图的信息表明本次Crash出现xxxViewController的323行，出错的函数调用为orderCountLoadFailed。</p>
<h3 id="Thread_State">Thread State</h3><p><img src="http://images.cnitblog.com/blog/302680/201501/052036460005028.png" alt=""></p>
<h3 id="Binary_Images">Binary Images</h3><p><img src="http://images.cnitblog.com/blog/302680/201501/052038193591674.png" alt=""><br>Crash时刻App加载的所有的库，其中第一行是Crash发生时我们App可执行文件的信息，可以看出为armv7，可执行文件的包得uuid位c0f……cd65，解析Crash的时候dsym文件的uuid必须和这个一样才能完成Crash的符号化解析。</p>
<h2 id="常见的Crash类型">常见的Crash类型</h2><h3 id="Watchdog_timeout">Watchdog timeout</h3><p>Exception Code：0x8badf00d， 不太直观，可以读成“eat bad food”，意思是don‘t block main thread</p>
<p>紧接着下面会有一段描述：</p>
<p>Application Specific Information：</p>
<p>com.xxx.yyy　　 failed to resume in time</p>
<p>对于此类Crash，我们应该去审视自己App初始化时做的事情是否正确，是否在主线程请求了网络，或者其他耗时的事情卡住了正常初始化流程。</p>
<p>通常系统允许一个App从启动到可以相应用户事件的时间最多为5S，如果超过了5S，App就会被系统终止掉。在Launch，resume，suspend，quit时都会有相应的时间要求。在Highlight Thread里面我们可以看到被终止时调用到的位置，xxxAppDelegate加上行号。 </p>
<p>PS. 在连接Xcode调试时为了便于调试，系统会暂时禁用掉Watchdog，所以此类问题的发现需要使用正常的启动模式。</p>
<h3 id="User_force-quit">User force-quit</h3><p>Exception Codes: 0xdeadfa11, deadfall</p>
<p>这个强制退出跟我们平时所说的kill掉后台任务操作还不太一样，通常在程序bug造成系统无法响应时可以采用长按电源键，当屏幕出现关机确认画面时按下Home键即可关闭当前程序。</p>
<h3 id="Low_Memory_termination">Low Memory termination</h3><p>跟一般的Crash结构不太一样，通常有Free pages，Wired Pages，Purgeable pages，largest process 组成，同事会列出当前时刻系统运行所有进程的信息。</p>
<p>关于Memory warning可以参看我之前写的一篇文章IOS 内存警告 Memory warning level。</p>
<p>App在运行过程中，系统内存紧张时通常会先发警告，同时把后台挂起的程序终止掉，最终如果还是内存不够的话就会终止掉当前前台的进程。</p>
<p>当接受到内存警告的事后，我们应该释放尽可能多的内存，Crash其实也可以看做是对App的一种保护。</p>
<h3 id="Crash_due_to_bugs">Crash due to bugs</h3><p>因为程序bug导致的Crash通常千奇百怪，很难一概而论。大部分情况通过Crash日志就可以定位出问题，当然也不排除部分疑难杂症看半天都不值问题出在哪儿。这个就只能看功底了，一点点找，总是能发现蛛丝马迹。是在看不出来时还可以求助于Google大神，总有人遇到和你一样的Bug </p>
<h2 id="常见的Exception_Type_&amp;_Exception_Code">常见的Exception Type &amp; Exception Code</h2><h3 id="Exception_Type">Exception Type</h3><p>1）EXC_BAD_ACCESS</p>
<p>此类型的Excpetion是我们最长碰到的Crash，通常用于访问了不改访问的内存导致。一般EXC_BAD_ACCESS后面的”()”还会带有补充信息。</p>
<p>SIGSEGV: 通常由于重复释放对象导致，这种类型在切换了ARC以后应该已经很少见到了。</p>
<p>SIGABRT:  收到Abort信号退出，通常Foundation库中的容器为了保护状态正常会做一些检测，例如插入nil到数组中等会遇到此类错误。</p>
<p>SEGV:（Segmentation  Violation），代表无效内存地址，比如空指针，未初始化指针，栈溢出等；</p>
<p>SIGBUS：总线错误，与 SIGSEGV 不同的是，SIGSEGV 访问的是无效地址，而 SIGBUS 访问的是有效地址，但总线访问异常(如地址对齐问题)</p>
<p>SIGILL：尝试执行非法的指令，可能不被识别或者没有权限</p>
<p>2）EXC_BAD_INSTRUCTION<br>此类异常通常由于线程执行非法指令导致</p>
<p>3）EXC_ARITHMETIC<br>除零错误会抛出此类异常</p>
<h3 id="Exception_Code">Exception Code</h3><table>
<thead>
<tr>
<th>字段</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0xbaaaaaad</td>
<td>此种类型的log意味着该Crash log并非一个真正的Crash，它仅仅只是包含了整个系统某一时刻的运行状态。通常可以通过同时按Home键和音量键，可能由于用户不小心触发</td>
</tr>
<tr>
<td>0xbad22222</td>
<td>当VOIP程序在后台太过频繁的激活时，系统可能会终止此类程序</td>
</tr>
<tr>
<td>0x8badf00d</td>
<td>这个前面已经介绍了，程序启动或者恢复时间过长被watch dog终止</td>
</tr>
<tr>
<td>0xc00010ff</td>
<td>程序执行大量耗费CPU和GPU的运算，导致设备过热，触发系统过热保护被系统终止</td>
</tr>
<tr>
<td>0xdead10cc</td>
<td>程序退到后台时还占用系统资源，如通讯录被系统终止</td>
</tr>
<tr>
<td>0xdeadfa11</td>
<td>前面也提到过，程序无响应用户强制关闭</td>
</tr>
</tbody>
</table>
<h3 id="获取Crash的途径">获取Crash的途径</h3><p>1、本机</p>
<p>通过xCode连接测试机器，直接在Device中即可读取到该机器上发生的所有Crash log。</p>
<p>2、itunes connect</p>
<p>通过itunes connect后台获取到用户上报的Crash日志。</p>
<p>3、第三方的Crash收集系统</p>
<p>有很多优秀的第三方Crash收集系统大大的方便了我们收集Crash，甚至还带了符号化Crash日志的功能。比较常用的有<a href="http://www.crashlytics.com/" target="_blank" rel="external">Crashlytics</a>，<a href="http://www.flurry.com/" target="_blank" rel="external">Flurry</a>等。</p>
<h2 id="附录">附录</h2><p>Apple官方文档：<a href="https://developer.apple.com/library/ios/technotes/tn2151/_index.html#//apple_ref/doc/uid/DTS40008184-CH1-INTRODUCTION" target="_blank" rel="external">Understanding and Analyzing iOS Application Crash Reports</a></p>
<p>　　　　　　　　<a href="https://developer.apple.com/library/mac/technotes/tn2004/tn2123.html#LISTCRASHLOGEXCEPTION" target="_blank" rel="external">Technical Note TN2123 CrashReporter</a></p>
<p>　　　　　　　　<a href="https://developer.apple.com/library/ios/qa/qa1592/_index.html" target="_blank" rel="external">https://developer.apple.com/library/ios/qa/qa1592/_index.html</a></p>
<p>WWDC视频： 　<a href="https://developer.apple.com/videos/wwdc/2010/?id=317" target="_blank" rel="external">Understanding Crash Reports on iPhone OS</a>　　</p>
<p>　　Crash日志记录的时候是将Crash发生时刻，函数的调用栈，以及线程等信息写入文件。一般都是直接写的16进制地址，如果不经过符号化的话，基本上很难获取到有用信息，下一篇我们将聊一聊Crash日志的符号化，通俗点讲就是让Crash日志变成我们可读的格式。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>转载自：<a href="http://www.cnblogs.com/smileEvday/p/Crash1.html">http://www.cnblogs.com/smileEvday/p/Crash1.html</a></p>
<p>　　开发程序的过程中不管我们已经如何小心，总是会在不经意间遇到程序闪退。脑补一下当你在一群人面前自信的拿着你的App做功能预演的时候，流畅的操作被无情地Crash打断。联想起老罗在发布Smartisan OS的时候说了，他准备了10个手机，如果一台有问题，就换一台，如果10台后挂了他就不做手机了。好了不闲扯了，今天就跟大家一起聊聊iOSCrash文件的组成以及常用的分析工具。</p>
<p>　　有一个WWDC 2010的视频推荐大家抽空看看，视频名称<a href="https://developer.apple.com/videos/wwdc/2010/?id=317">“Understanding Crash Reports on iPhone OS”</a>，该视频详细讲解了Crash文件的结构。当然如果你没时间看的话，不妨阅读以下这篇文章。<br>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://jatwaston.github.io/tags/iOS/"/>
    
      <category term="转载" scheme="http://jatwaston.github.io/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="iOS开发" scheme="http://jatwaston.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[svn冲突的解决方式]]></title>
    <link href="http://jatwaston.github.io/2015/04/24/svn-revert-solution/"/>
    <id>http://jatwaston.github.io/2015/04/24/svn-revert-solution/</id>
    <published>2015-04-24T01:15:38.000Z</published>
    <updated>2015-04-24T01:44:17.000Z</updated>
    <content type="html"><![CDATA[<p><code>svn up</code>的时候很经常会出现冲突，今天介绍两种最常见冲突的解决方式</p>
<h2 id="svn_local_delete,_incoming_delete_upon_update的解决方式">svn local delete, incoming delete upon update的解决方式</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//In your working directory, recreate that conflicting file:</span></span><br><span class="line">$ touch foo</span><br><span class="line"><span class="comment">//Revert that file to the state SVN likes (that means deleted):</span></span><br><span class="line">$ svn revert foo</span><br><span class="line"><span class="comment">//Now delete that file:</span></span><br><span class="line">$ rm foo</span><br><span class="line"><span class="comment">//Conflict resolved:</span></span><br><span class="line">$ svn st</span><br><span class="line"><span class="comment">//Done.</span></span><br></pre></td></tr></table></figure>
<h2 id="local_unversioned,_incoming_add_upon_update的解决方式">local unversioned, incoming add upon update的解决方式</h2><p>当<code>svn up</code>的时候出现<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C Runtime</span><br><span class="line">&gt;<span class="built_in">local</span> unversioned, incoming <span class="built_in">add</span> upon update</span><br></pre></td></tr></table></figure></p>
<p>这是命令行下的svn树冲突了，（文件本身没有改变，只是本地版本库里面出现冲突而已）解决方法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">svn resolve --accept working ./Runtime</span><br><span class="line"><span class="comment">//Resolved conflicted state of 'Runtime'</span></span><br><span class="line">svn revert ./Runtime</span><br><span class="line"><span class="comment">//Reverted 'Runtime'</span></span><br><span class="line">svn status</span><br></pre></td></tr></table></figure>
<p>通过以上的步骤就能移除掉本地svn版本库的冲突信息</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><code>svn up</code>的时候很经常会出现冲突，今天介绍两种最常见冲突的解决方式</p>
<h2 id="svn_local_delete,_incoming_delete_upon_update的解决方式">svn local delete, incomin]]>
    </summary>
    
      <category term="版本控制" scheme="http://jatwaston.github.io/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="svn &amp; git" scheme="http://jatwaston.github.io/categories/svn-git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[UISearchDisplayController的用法]]></title>
    <link href="http://jatwaston.github.io/2015/04/01/uisearchdisplay/"/>
    <id>http://jatwaston.github.io/2015/04/01/uisearchdisplay/</id>
    <published>2015-04-01T01:33:48.000Z</published>
    <updated>2015-04-29T09:36:54.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前记">前记</h2><p>　　<code>UISearchDisplayController</code>是iOS开发中专门为<code>UITableView</code>提供搜索而封装的一个类，平时开发的时候也没怎么用到，这次趁着项目开发中用到它，做了下笔记，方便下次再次用到的时候查找方便。<br>　　<a id="more"></a></p>
<h2 id="UISearchDisplayController介绍">UISearchDisplayController介绍</h2><p>　　<code>UISearchDisplayController</code>是用来提供搜索展示的，兼容<code>3.0~8.0</code>,<code>8.0</code>之后就过期了，被<code>UISearchController</code>所取代，这次主要讲如何使用<code>UISearchDisplayController</code>以及在使用中碰到的一些问题，先来看下项目中结合<code>UISearchDisplayController</code>做搜索是一个怎样的效果，先上图！<br>　　<img src="http://7xijmx.com1.z0.glb.clouddn.com/search.gif" alt=""><br>整体的动画效果很流畅，如果是我们自己来做这个动画，估计也不容易，接下来我们来看看项目中如何使用<code>UISearchDisplayController</code>吧！</p>
<h2 id="UISearchDisplayController使用">UISearchDisplayController使用</h2><p>　　<code>UISearchDisplayController</code>的使用场景是<code>UITableView</code>+<code>UISearchBar</code>+<code>带有UINavigationController结构的UIViewController</code>，这些东西如何创建我就不啰嗦了，直奔主题吧！</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">　　- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span><span class="variable">.title</span> = <span class="string">@"Apple"</span>;</span><br><span class="line">    </span><br><span class="line">    _contentArray = [[<span class="built_in">NSMutableArray</span> alloc] initWithObjects:<span class="string">@"iPhone"</span>,<span class="string">@"iPod"</span>,<span class="string">@"iPod touch"</span>,<span class="string">@"iPad"</span>,<span class="string">@"iPad mini"</span>,<span class="string">@"iMac"</span>,<span class="string">@"Mac Pro"</span>,<span class="string">@"MacBook Air"</span>,<span class="string">@"MacBook Pro"</span>, <span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    _contentTableView = [[<span class="built_in">UITableView</span> alloc] initWithFrame:<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.bounds</span> style:UITableViewStylePlain];</span><br><span class="line">    _contentTableView<span class="variable">.dataSource</span> = <span class="keyword">self</span>;</span><br><span class="line">    _contentTableView<span class="variable">.delegate</span> = <span class="keyword">self</span>;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span> addSubview:_contentTableView];</span><br><span class="line">    [<span class="keyword">self</span> addSearchBar];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addSearchBar &#123;</span><br><span class="line">    _searchBar = [[<span class="built_in">UISearchBar</span> alloc] initWithFrame:CGRectMake(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.width</span>, <span class="number">44</span>)];</span><br><span class="line"><span class="comment">//    _searchBar.scopeButtonTitles = [NSArray arrayWithObjects:@"All",@"Device",@"Potable", nil]; </span></span><br><span class="line">    _contentTableView<span class="variable">.tableHeaderView</span> = _searchBar;</span><br><span class="line"><span class="comment">//    [_contentTableView.tableHeaderView addSubview:_searchBar];</span></span><br><span class="line">    _searchDisplayController = [[UISearchDisplayController alloc] initWithSearchBar:_searchBar contentsController:<span class="keyword">self</span>];</span><br><span class="line">    _searchDisplayController<span class="variable">.searchResultsDataSource</span> = <span class="keyword">self</span>;</span><br><span class="line">    _searchDisplayController<span class="variable">.searchResultsDelegate</span> = <span class="keyword">self</span>;</span><br><span class="line">    _searchDisplayController<span class="variable">.delegate</span> = <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - UITableViewDataSource</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>)tableView:(<span class="built_in">UITableView</span> *)tableView numberOfRowsInSection:(<span class="built_in">NSInteger</span>)section &#123;</span><br><span class="line">    <span class="comment">//需要判断该tableView是界面展示的tableView还是搜索结果的tableView</span></span><br><span class="line">    <span class="keyword">if</span> (tableView == _contentTableView) &#123;</span><br><span class="line">        <span class="keyword">return</span> [_contentArray count];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        NSPredicate *predicate = [NSPredicate predicateWithFormat:<span class="string">@"self contains [cd] %@"</span>,_searchDisplayController<span class="variable">.searchBar</span><span class="variable">.text</span>];</span><br><span class="line">        _filterData =  [[<span class="built_in">NSArray</span> alloc] initWithArray:[_contentArray filteredArrayUsingPredicate:predicate]];</span><br><span class="line">        <span class="keyword">return</span> _filterData<span class="variable">.count</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSString</span> *cellStr = <span class="string">@"cell"</span>;</span><br><span class="line">    <span class="built_in">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:cellStr];</span><br><span class="line">    <span class="keyword">if</span> (cell == <span class="literal">nil</span>) &#123;</span><br><span class="line">        cell = [[<span class="built_in">UITableViewCell</span> alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:cellStr];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tableView == _contentTableView) &#123;</span><br><span class="line">        cell<span class="variable">.textLabel</span><span class="variable">.text</span> = [_contentArray objectAtIndex:[indexPath row]];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cell<span class="variable">.textLabel</span><span class="variable">.text</span> = [_filterData objectAtIndex:[indexPath row]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单的代码就能使用<code>UISearchDisplayController</code>，代码里面用到了<code>NSPredicate</code>，这个有点类似正则表达，是用来过滤结果使用的，具体的介绍请移步到此<a href="http://www.cocoachina.com/industry/20140321/8024.html" target="_blank" rel="external">NSPredicate介绍</a>，接下来我们来玩点高级的。</p>
<h2 id="UISearchDisplayController高级用法">UISearchDisplayController高级用法</h2><h3 id="使用自定义的搜索界面">使用自定义的搜索界面</h3><p>　　如果觉得系统提供的搜索结果界面无法满足项目需求，需要自定义的时候，我们就需要使用到<code>UISearchDisplayController</code>的delegate了，它提供了很多了委托方法，请自行查看<code>UISearchDisplayDelegate</code>，这里就不一一列举了，在自定义搜索界面的时候，我用到了其中3个回调，暂时能满足需求了</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//搜索动画即将开始的时候回调</span><br><span class="line"><span class="pp">- <span class="params">(void)</span> searchDisplayControllerWillBeginSearch:<span class="params">(<span class="variable">UISearchDisplayController</span> *)</span>controller NS_DEPRECATED_IOS<span class="params">(<span class="number">3</span>_0,<span class="number">8</span>_0)</span>; </span><br><span class="line">//搜索动画即将结束的时候回调</span><br><span class="line">- <span class="params">(void)</span> searchDisplayControllerWillEndSearch:<span class="params">(<span class="variable">UISearchDisplayController</span> *)</span>controller NS_DEPRECATED_IOS<span class="params">(<span class="number">3</span>_0,<span class="number">8</span>_0)</span>;</span><br><span class="line">//显示搜索结果的回调</span><br><span class="line">- <span class="params">(void)</span>searchDisplayController:<span class="params">(<span class="variable">UISearchDisplayController</span> *)</span>controller didShowSearchResultsTableView:<span class="params">(<span class="variable">UITableView</span> *)</span>tableView NS_DEPRECATED_IOS<span class="params">(<span class="number">3</span>_0,<span class="number">8</span>_0)</span>;</span></span><br></pre></td></tr></table></figure>
<p>具体的实现方案如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(void)</span> searchDisplayControllerWillBeginSearch:<span class="params">(<span class="variable">UISearchDisplayController</span> *)</span>controller NS_DEPRECATED_IOS<span class="params">(<span class="number">3</span>_0,<span class="number">8</span>_0)</span> &#123;</span><br><span class="line">    _searchResultController = [[SearchResultViewController alloc] init];</span><br><span class="line">    [controller</span>.search<span class="variable">ContentsController</span> add<span class="variable">ChildViewController</span>:<span class="variable">_</span>search<span class="variable">ResultController</span>];</span><br><span class="line">    [controller.search<span class="variable">ContentsController</span>.view add<span class="variable">Subview</span>:<span class="variable">_</span>search<span class="variable">ResultController</span>.view];</span><br><span class="line">    [controller.search<span class="variable">ContentsController</span>.view bring<span class="variable">SubviewToFront</span>:<span class="variable">_</span>search<span class="variable">ResultController</span>.view];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="pp">- <span class="params">(void)</span> searchDisplayControllerWillEndSearch:<span class="params">(<span class="variable">UISearchDisplayController</span> *)</span>controller NS_DEPRECATED_IOS<span class="params">(<span class="number">3</span>_0,<span class="number">8</span>_0)</span> &#123;</span><br><span class="line">    if <span class="params">(<span class="variable">_</span>search<span class="variable">ResultController</span>)</span> &#123;</span><br><span class="line">        [_searchResultController</span>.view remove<span class="variable">FromSuperview</span>];</span><br><span class="line">        [<span class="variable">_</span>search<span class="variable">ResultController</span> remove<span class="variable">FromParentViewController</span>];</span><br><span class="line">        <span class="variable">_</span>search<span class="variable">ResultController</span> = nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="pp">- <span class="params">(void)</span>searchDisplayController:<span class="params">(<span class="variable">UISearchDisplayController</span> *)</span>controller didShowSearchResultsTableView:<span class="params">(<span class="variable">UITableView</span> *)</span>tableView NS_DEPRECATED_IOS<span class="params">(<span class="number">3</span>_0,<span class="number">8</span>_0)</span> &#123;</span><br><span class="line">    tableView</span>.hidden = <span class="variable">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这些代码就能实现去掉系统自带的搜索结果界面，而使用自定义的搜索界面了。这代码有很多优化的地方，我这边只是介绍实现方案，具体项目具体处理，优化方案就不再这里讨论了。</p>
<h3 id="去掉半透明遮罩">去掉半透明遮罩</h3><p>　　如果上面我们使用了自定义的搜索界面，但是有个很可恶的东西，就是在还没搜索前有个半透明的遮罩<img src="http://7xijmx.com1.z0.glb.clouddn.com/5.12.471.png" alt="">（这个半透明遮罩有人觉得好，有人觉得不好，主要是看项目需求，我的项目里面不需要用它，所以要把它去掉），界面上不是特别美观，所以就要想方设法把它去掉。<br><br>　　一开始本来还想通过寻找委托函数来实现该方案，但是都没能找到一个适合的（也许我找的有问题，如果能通过委托函数来实现的，麻烦告知一下，我也学习下）,最后发现<code>UISearchDisplayController</code>有个这样的函数<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="typename">void</span>)<span class="string">setActive:</span>(BOOL)visible <span class="string">animated:</span>(BOOL)animated;       <span class="comment">// animate the view controller for searching</span></span><br></pre></td></tr></table></figure></p>
<p>它是在用户点击<code>UISearchBar</code>做收起动画的时候以及用户点击<code>Cancel</code>按钮的时候都会触发的，我们可以直接在该函数里面实现我们去掉半透明遮罩的功能，具体方案如下:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setActive:(<span class="built_in">BOOL</span>)visible animated:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">self</span><span class="variable">.active</span> == visible) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">super</span> setActive:visible animated:animated];</span><br><span class="line">    <span class="built_in">NSArray</span> *subViews = <span class="keyword">self</span><span class="variable">.searchContentsController</span><span class="variable">.view</span><span class="variable">.subviews</span>;</span><br><span class="line">    <span class="keyword">if</span> ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= <span class="number">7.0</span>f) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">UIView</span> *view <span class="keyword">in</span> subViews) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([view isKindOfClass:NSClassFromString(<span class="string">@"UISearchDisplayControllerContainerView"</span>)]) &#123;</span><br><span class="line">                <span class="built_in">NSArray</span> *sub = view<span class="variable">.subviews</span>;</span><br><span class="line">                ((<span class="built_in">UIView</span>*)sub[<span class="number">2</span>])<span class="variable">.hidden</span> = <span class="literal">YES</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [[subViews lastObject] removeFromSuperview];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现后再次点击<code>UISearchBar</code>的时候：<br><img src="http://7xijmx.com1.z0.glb.clouddn.com/5.12.241.png" alt=""><br>半透明遮罩消失了，大功告成！<br><br>　　最后整个工程的代码已经上传到Github上，大家可以到<a href="https://github.com/JatWaston/iOS-Codes/tree/master/SearchDemo" target="_blank" rel="external">这里</a>下载，有任何问题，欢迎讨论。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前记">前记</h2><p>　　<code>UISearchDisplayController</code>是iOS开发中专门为<code>UITableView</code>提供搜索而封装的一个类，平时开发的时候也没怎么用到，这次趁着项目开发中用到它，做了下笔记，方便下次再次用到的时候查找方便。<br>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://jatwaston.github.io/tags/iOS/"/>
    
      <category term="iOS开发" scheme="http://jatwaston.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac下显示隐藏文件]]></title>
    <link href="http://jatwaston.github.io/2015/03/31/new-post/"/>
    <id>http://jatwaston.github.io/2015/03/31/new-post/</id>
    <published>2015-03-31T08:02:14.000Z</published>
    <updated>2015-04-01T01:41:53.000Z</updated>
    <content type="html"><![CDATA[<p>在终端输入以下代码:</p>
<p>显示的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.finder AppleShowAllFiles -<span class="keyword">bool</span> <span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<p>隐藏的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.finder AppleShowAllFiles -<span class="keyword">bool</span> <span class="keyword">false</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>在终端输入以下代码:</p>
<p>显示的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td]]>
    </summary>
    
      <category term="Mac" scheme="http://jatwaston.github.io/tags/Mac/"/>
    
      <category term="Mac Tips" scheme="http://jatwaston.github.io/categories/Mac-Tips/"/>
    
  </entry>
  
</feed>