<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[编程时间]]></title>
  <subtitle><![CDATA[Write the code. Change the world.]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://jatwaston.github.io/"/>
  <updated>2015-04-25T00:45:35.000Z</updated>
  <id>http://jatwaston.github.io/</id>
  
  <author>
    <name><![CDATA[JatWaston]]></name>
    <email><![CDATA[support@jatwaston.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Python爬虫学习（一）]]></title>
    <link href="http://jatwaston.github.io/2015/04/25/Python-Spider-1/"/>
    <id>http://jatwaston.github.io/2015/04/25/Python-Spider-1/</id>
    <published>2015-04-24T23:29:54.000Z</published>
    <updated>2015-04-25T00:45:35.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前记">前记</h2><p>　　一直从事于iOS开发多年，所接触的大部分都是客户端的开发，处理服务端的数据，逻辑处理，然后展示给用户，其实一直以来对服务端的开发还是比较感兴趣的，本着编程语言是相通的想法，所以业余时间就学了点服务端的开发，接触过PHP和Python,总感觉Python学起来会容易点（PHPer不要喷我啊，这只是小弟的想法，不要做语言攻击啊），而且最近自己也在学习Python爬虫，所以就纯当纪录下自己学习Python的笔记了，因为小弟属于刚学习阶段，能力有限，如果有说错的地方，欢迎指出。
　　</p>
<h2 id="什么是Python爬虫">什么是Python爬虫</h2><p>　　底下这段话是百度百科对网络爬虫的解释<br>　　<blockquote class="blockquote-center">网络爬虫（又被称为网页蜘蛛，网络机器人，在FOAF社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动的抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁，自动索引，模拟程序或者蠕虫。</blockquote><br>　　<a id="more"></a><br>　　其实说简单点就是一段自动化执行的程序，用来在网络上爬取你想要的内容，最出名的网络爬虫应用算是google的网络爬虫和百度的网络爬虫了，他们每天都要爬取网络上海量的数据，bla bla bla爬取数据，然后再做数据分析处理，然后通过搜索展示给我们，可以说网络爬虫是搜索引擎的根基。<br>　　今天我要讲的网络爬虫肯定没有那么搜索引擎所用的爬虫那么高深，毕竟我只是个初学者，而且还是个学渣啊<img src="http://7xijmx.com1.z0.glb.clouddn.com/20130703155605_CYHZQ.thumb.600_0.jpeg" alt="">，掩面而过啊，但是我相信复杂的东西其实都是由很多简单的东西构成的，所以今天就来讲下最简单的网络爬虫，走起！</p>
<h2 id="编写你的第一个网络爬虫">编写你的第一个网络爬虫</h2><p>　　看了上面这么多废话，相信你也烦了，那我们直接开始吧，在开始之前我再废话一句啊（博主，你够了，信不信我拿刀砍死你啊，<img src="http://7xijmx.com1.z0.glb.clouddn.com/20130703155605_CYHZQ.thumb.600_0.jpeg" alt="">），保证是最后一句了，就是小弟用的Python是<strong>2.7</strong>系列的，Python 3系列的听说改动较多，如果代码无法运行，请先检查你的Python版本。<br>而且运行系统是<strong>Mac</strong>,Windows下如果无法运行我暂时也解决不了，因为我已经好几年没在Windows下写程序了，哈哈哈！<br>　　<blockquote class="blockquote-center">Talk is cheap. Show me the code.<br>　　Linus Torvalds</blockquote><br>翠花，上酸菜，不，上代码！<br><code>baidu.py</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8 </span></span><br><span class="line"><span class="keyword">import</span> urllib2 <span class="comment">#引入python自带的urllib2库</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetchWebPage</span><span class="params">(url)</span>:</span></span><br><span class="line">	page = urllib2.urlopen(url); <span class="comment">#打开url链接</span></span><br><span class="line">	html = page.read() <span class="comment">#读取网页内容</span></span><br><span class="line">	<span class="keyword">return</span> html; <span class="comment">#返回结果</span></span><br><span class="line"></span><br><span class="line">htmlContent = fetchWebPage(<span class="string">"http://www.baidu.com/"</span>)</span><br><span class="line"><span class="keyword">print</span> htmlContent</span><br></pre></td></tr></table></figure>
<p>代码已经写的够简单了，相信大家都看的懂了，我就不废话了，希望大家有机会的话也去敲敲代码实现下。下一次将为大家讲解下从爬取回来的网页中获取自己想要的内容。</p>
<p>　　
　　
　　</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前记">前记</h2><p>　　一直从事于iOS开发多年，所接触的大部分都是客户端的开发，处理服务端的数据，逻辑处理，然后展示给用户，其实一直以来对服务端的开发还是比较感兴趣的，本着编程语言是相通的想法，所以业余时间就学了点服务端的开发，接触过PHP和Python,总感觉Python学起来会容易点（PHPer不要喷我啊，这只是小弟的想法，不要做语言攻击啊），而且最近自己也在学习Python爬虫，所以就纯当纪录下自己学习Python的笔记了，因为小弟属于刚学习阶段，能力有限，如果有说错的地方，欢迎指出。
　　</p>
<h2 id="什么是Python爬虫">什么是Python爬虫</h2><p>　　底下这段话是百度百科对网络爬虫的解释<br>　　<blockquote class="blockquote-center">网络爬虫（又被称为网页蜘蛛，网络机器人，在FOAF社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动的抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁，自动索引，模拟程序或者蠕虫。</blockquote><br>]]>
    
    </summary>
    
      <category term="Python" scheme="http://jatwaston.github.io/tags/Python/"/>
    
      <category term="Python开发" scheme="http://jatwaston.github.io/categories/Python%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS Crash文件的解析]]></title>
    <link href="http://jatwaston.github.io/2015/04/24/iOS-Crash/"/>
    <id>http://jatwaston.github.io/2015/04/24/iOS-Crash/</id>
    <published>2015-04-24T02:29:55.000Z</published>
    <updated>2015-04-24T04:46:58.000Z</updated>
    <content type="html"><![CDATA[<p>转载自：<a href="http://www.cnblogs.com/smileEvday/p/Crash1.html" target="_blank" rel="external">http://www.cnblogs.com/smileEvday/p/Crash1.html</a></p>
<p>　　开发程序的过程中不管我们已经如何小心，总是会在不经意间遇到程序闪退。脑补一下当你在一群人面前自信的拿着你的App做功能预演的时候，流畅的操作被无情地Crash打断。联想起老罗在发布Smartisan OS的时候说了，他准备了10个手机，如果一台有问题，就换一台，如果10台后挂了他就不做手机了。好了不闲扯了，今天就跟大家一起聊聊iOSCrash文件的组成以及常用的分析工具。</p>
<p>　　有一个WWDC 2010的视频推荐大家抽空看看，视频名称<a href="https://developer.apple.com/videos/wwdc/2010/?id=317" target="_blank" rel="external">“Understanding Crash Reports on iPhone OS”</a>，该视频详细讲解了Crash文件的结构。当然如果你没时间看的话，不妨阅读以下这篇文章。<br>　　<a id="more"></a></p>
<h2 id="Crash文件结构">Crash文件结构</h2><p>当程序运行Crash的时候，系统会把运行的最后时刻的运行信息记录下来，存储到一个文件中，也就是我们所说的Crash文件。iOS的Crash日志通常由以下6各部分组成。</p>
<h3 id="Process_Information(进程信息)">Process Information(进程信息)</h3><p><img src="http://images.cnitblog.com/blog/302680/201412/230718553901251.png" alt=""></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Incident Idnetifier</td>
<td>崩溃报告的唯一标识符，不同的Crash</td>
</tr>
<tr>
<td>CrashReporter Key</td>
<td>设备标识相对应的唯一键值(并非真正的设备的UDID，苹果为了保护用户隐私iOS6以后已经无法获取)。通常同一个设备上同一版本的App发生Crash时，该值都是一样的。</td>
</tr>
<tr>
<td>Hardware Model</td>
<td>代表发生Crash的设备类型，上图中的“iPad4,4”代表iPad Air</td>
</tr>
<tr>
<td>Process</td>
<td>代表Crash的进程名称，通常都是我们的App的名字, []里面是当时进程的ID</td>
</tr>
<tr>
<td>Path</td>
<td>可执行程序在手机上的存储位置，注意路径时到XXX.app/XXX，XXX.app其实是作为一个Bundle的，真正的可执行文件其实是Bundle里面的XXX，感兴趣的可以自己查一下相关资料，有机会我后面也会介绍到</td>
</tr>
<tr>
<td>Identifier</td>
<td>你的App的Indentifier，通常为“com.xxx.yyy”，xxx代表你们公司的域名，yyy代表某一个App</td>
</tr>
<tr>
<td>Version</td>
<td>当前App的版本号，由Info.plist中的两个字段组成，CFBundleShortVersionString and CFBundleVersion</td>
</tr>
<tr>
<td>Code Type</td>
<td>当前App的CPU架构</td>
</tr>
<tr>
<td>Parent Process</td>
<td>当前进程的父进程，由于iOS中App通常都是单进程的，一般父进程都是launchd</td>
</tr>
</tbody>
</table>
<h3 id="Basic_Information">Basic Information</h3><p><img src="http://images.cnitblog.com/blog/302680/201501/052025393435295.png" alt=""></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Date/Time</td>
<td>Crash发生的时间，可读的字符串</td>
</tr>
<tr>
<td>OS Version</td>
<td>系统版本，（）内的数字代表的时Bulid号</td>
</tr>
<tr>
<td>Report Version</td>
<td>Crash日志的格式，目前基本上都是104，不同的version里面包含的字段可能有不同</td>
</tr>
</tbody>
</table>
<h3 id="Exception（非常重要）">Exception（非常重要）</h3><p><img src="http://images.cnitblog.com/blog/302680/201501/052029230317758.png" alt=""></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Exception Type</td>
<td>异常类型</td>
</tr>
<tr>
<td>Exception Subtype</td>
<td>异常子类型</td>
</tr>
<tr>
<td>Crashed Thread</td>
<td>发生异常的线程号</td>
</tr>
</tbody>
</table>
<h3 id="Thread_Backtrace">Thread Backtrace</h3><p><img src="http://images.cnitblog.com/blog/302680/201501/052034366876268.png" alt=""><br>发生Crash的线程的Crash调用栈，从上到下分别代表调用顺序，最上面的一个表示抛出异常的位置，依次往下可以看到API的调用顺序。上图的信息表明本次Crash出现xxxViewController的323行，出错的函数调用为orderCountLoadFailed。</p>
<h3 id="Thread_State">Thread State</h3><p><img src="http://images.cnitblog.com/blog/302680/201501/052036460005028.png" alt=""></p>
<h3 id="Binary_Images">Binary Images</h3><p><img src="http://images.cnitblog.com/blog/302680/201501/052038193591674.png" alt=""><br>Crash时刻App加载的所有的库，其中第一行是Crash发生时我们App可执行文件的信息，可以看出为armv7，可执行文件的包得uuid位c0f……cd65，解析Crash的时候dsym文件的uuid必须和这个一样才能完成Crash的符号化解析。</p>
<h2 id="常见的Crash类型">常见的Crash类型</h2><h3 id="Watchdog_timeout">Watchdog timeout</h3><p>Exception Code：0x8badf00d， 不太直观，可以读成“eat bad food”，意思是don‘t block main thread</p>
<p>紧接着下面会有一段描述：</p>
<p>Application Specific Information：</p>
<p>com.xxx.yyy　　 failed to resume in time</p>
<p>对于此类Crash，我们应该去审视自己App初始化时做的事情是否正确，是否在主线程请求了网络，或者其他耗时的事情卡住了正常初始化流程。</p>
<p>通常系统允许一个App从启动到可以相应用户事件的时间最多为5S，如果超过了5S，App就会被系统终止掉。在Launch，resume，suspend，quit时都会有相应的时间要求。在Highlight Thread里面我们可以看到被终止时调用到的位置，xxxAppDelegate加上行号。 </p>
<p>PS. 在连接Xcode调试时为了便于调试，系统会暂时禁用掉Watchdog，所以此类问题的发现需要使用正常的启动模式。</p>
<h3 id="User_force-quit">User force-quit</h3><p>Exception Codes: 0xdeadfa11, deadfall</p>
<p>这个强制退出跟我们平时所说的kill掉后台任务操作还不太一样，通常在程序bug造成系统无法响应时可以采用长按电源键，当屏幕出现关机确认画面时按下Home键即可关闭当前程序。</p>
<h3 id="Low_Memory_termination">Low Memory termination</h3><p>跟一般的Crash结构不太一样，通常有Free pages，Wired Pages，Purgeable pages，largest process 组成，同事会列出当前时刻系统运行所有进程的信息。</p>
<p>关于Memory warning可以参看我之前写的一篇文章IOS 内存警告 Memory warning level。</p>
<p>App在运行过程中，系统内存紧张时通常会先发警告，同时把后台挂起的程序终止掉，最终如果还是内存不够的话就会终止掉当前前台的进程。</p>
<p>当接受到内存警告的事后，我们应该释放尽可能多的内存，Crash其实也可以看做是对App的一种保护。</p>
<h3 id="Crash_due_to_bugs">Crash due to bugs</h3><p>因为程序bug导致的Crash通常千奇百怪，很难一概而论。大部分情况通过Crash日志就可以定位出问题，当然也不排除部分疑难杂症看半天都不值问题出在哪儿。这个就只能看功底了，一点点找，总是能发现蛛丝马迹。是在看不出来时还可以求助于Google大神，总有人遇到和你一样的Bug </p>
<h2 id="常见的Exception_Type_&amp;_Exception_Code">常见的Exception Type &amp; Exception Code</h2><h3 id="Exception_Type">Exception Type</h3><p>1）EXC_BAD_ACCESS</p>
<p>此类型的Excpetion是我们最长碰到的Crash，通常用于访问了不改访问的内存导致。一般EXC_BAD_ACCESS后面的”()”还会带有补充信息。</p>
<p>SIGSEGV: 通常由于重复释放对象导致，这种类型在切换了ARC以后应该已经很少见到了。</p>
<p>SIGABRT:  收到Abort信号退出，通常Foundation库中的容器为了保护状态正常会做一些检测，例如插入nil到数组中等会遇到此类错误。</p>
<p>SEGV:（Segmentation  Violation），代表无效内存地址，比如空指针，未初始化指针，栈溢出等；</p>
<p>SIGBUS：总线错误，与 SIGSEGV 不同的是，SIGSEGV 访问的是无效地址，而 SIGBUS 访问的是有效地址，但总线访问异常(如地址对齐问题)</p>
<p>SIGILL：尝试执行非法的指令，可能不被识别或者没有权限</p>
<p>2）EXC_BAD_INSTRUCTION<br>此类异常通常由于线程执行非法指令导致</p>
<p>3）EXC_ARITHMETIC<br>除零错误会抛出此类异常</p>
<h3 id="Exception_Code">Exception Code</h3><table>
<thead>
<tr>
<th>字段</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0xbaaaaaad</td>
<td>此种类型的log意味着该Crash log并非一个真正的Crash，它仅仅只是包含了整个系统某一时刻的运行状态。通常可以通过同时按Home键和音量键，可能由于用户不小心触发</td>
</tr>
<tr>
<td>0xbad22222</td>
<td>当VOIP程序在后台太过频繁的激活时，系统可能会终止此类程序</td>
</tr>
<tr>
<td>0x8badf00d</td>
<td>这个前面已经介绍了，程序启动或者恢复时间过长被watch dog终止</td>
</tr>
<tr>
<td>0xc00010ff</td>
<td>程序执行大量耗费CPU和GPU的运算，导致设备过热，触发系统过热保护被系统终止</td>
</tr>
<tr>
<td>0xdead10cc</td>
<td>程序退到后台时还占用系统资源，如通讯录被系统终止</td>
</tr>
<tr>
<td>0xdeadfa11</td>
<td>前面也提到过，程序无响应用户强制关闭</td>
</tr>
</tbody>
</table>
<h3 id="获取Crash的途径">获取Crash的途径</h3><p>1、本机</p>
<p>通过xCode连接测试机器，直接在Device中即可读取到该机器上发生的所有Crash log。</p>
<p>2、itunes connect</p>
<p>通过itunes connect后台获取到用户上报的Crash日志。</p>
<p>3、第三方的Crash收集系统</p>
<p>有很多优秀的第三方Crash收集系统大大的方便了我们收集Crash，甚至还带了符号化Crash日志的功能。比较常用的有<a href="http://www.crashlytics.com/" target="_blank" rel="external">Crashlytics</a>，<a href="http://www.flurry.com/" target="_blank" rel="external">Flurry</a>等。</p>
<h2 id="附录">附录</h2><p>Apple官方文档：<a href="https://developer.apple.com/library/ios/technotes/tn2151/_index.html#//apple_ref/doc/uid/DTS40008184-CH1-INTRODUCTION" target="_blank" rel="external">Understanding and Analyzing iOS Application Crash Reports</a></p>
<p>　　　　　　　　<a href="https://developer.apple.com/library/mac/technotes/tn2004/tn2123.html#LISTCRASHLOGEXCEPTION" target="_blank" rel="external">Technical Note TN2123 CrashReporter</a></p>
<p>　　　　　　　　<a href="https://developer.apple.com/library/ios/qa/qa1592/_index.html" target="_blank" rel="external">https://developer.apple.com/library/ios/qa/qa1592/_index.html</a></p>
<p>WWDC视频： 　<a href="https://developer.apple.com/videos/wwdc/2010/?id=317" target="_blank" rel="external">Understanding Crash Reports on iPhone OS</a>　　</p>
<p>　　Crash日志记录的时候是将Crash发生时刻，函数的调用栈，以及线程等信息写入文件。一般都是直接写的16进制地址，如果不经过符号化的话，基本上很难获取到有用信息，下一篇我们将聊一聊Crash日志的符号化，通俗点讲就是让Crash日志变成我们可读的格式。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>转载自：<a href="http://www.cnblogs.com/smileEvday/p/Crash1.html">http://www.cnblogs.com/smileEvday/p/Crash1.html</a></p>
<p>　　开发程序的过程中不管我们已经如何小心，总是会在不经意间遇到程序闪退。脑补一下当你在一群人面前自信的拿着你的App做功能预演的时候，流畅的操作被无情地Crash打断。联想起老罗在发布Smartisan OS的时候说了，他准备了10个手机，如果一台有问题，就换一台，如果10台后挂了他就不做手机了。好了不闲扯了，今天就跟大家一起聊聊iOSCrash文件的组成以及常用的分析工具。</p>
<p>　　有一个WWDC 2010的视频推荐大家抽空看看，视频名称<a href="https://developer.apple.com/videos/wwdc/2010/?id=317">“Understanding Crash Reports on iPhone OS”</a>，该视频详细讲解了Crash文件的结构。当然如果你没时间看的话，不妨阅读以下这篇文章。<br>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://jatwaston.github.io/tags/iOS/"/>
    
      <category term="转载" scheme="http://jatwaston.github.io/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="iOS开发" scheme="http://jatwaston.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[svn冲突的解决方式]]></title>
    <link href="http://jatwaston.github.io/2015/04/24/svn-revert-solution/"/>
    <id>http://jatwaston.github.io/2015/04/24/svn-revert-solution/</id>
    <published>2015-04-24T01:15:38.000Z</published>
    <updated>2015-04-24T01:44:17.000Z</updated>
    <content type="html"><![CDATA[<p><code>svn up</code>的时候很经常会出现冲突，今天介绍两种最常见冲突的解决方式</p>
<h2 id="svn_local_delete,_incoming_delete_upon_update的解决方式">svn local delete, incoming delete upon update的解决方式</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//In your working directory, recreate that conflicting file:</span></span><br><span class="line">$ touch foo</span><br><span class="line"><span class="comment">//Revert that file to the state SVN likes (that means deleted):</span></span><br><span class="line">$ svn revert foo</span><br><span class="line"><span class="comment">//Now delete that file:</span></span><br><span class="line">$ rm foo</span><br><span class="line"><span class="comment">//Conflict resolved:</span></span><br><span class="line">$ svn st</span><br><span class="line"><span class="comment">//Done.</span></span><br></pre></td></tr></table></figure>
<h2 id="local_unversioned,_incoming_add_upon_update的解决方式">local unversioned, incoming add upon update的解决方式</h2><p>当<code>svn up</code>的时候出现<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C Runtime</span><br><span class="line">&gt;<span class="built_in">local</span> unversioned, incoming <span class="built_in">add</span> upon update</span><br></pre></td></tr></table></figure></p>
<p>这是命令行下的svn树冲突了，（文件本身没有改变，只是本地版本库里面出现冲突而已）解决方法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">svn resolve --accept working ./Runtime</span><br><span class="line"><span class="comment">//Resolved conflicted state of 'Runtime'</span></span><br><span class="line">svn revert ./Runtime</span><br><span class="line"><span class="comment">//Reverted 'Runtime'</span></span><br><span class="line">svn status</span><br></pre></td></tr></table></figure>
<p>通过以上的步骤就能移除掉本地svn版本库的冲突信息</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><code>svn up</code>的时候很经常会出现冲突，今天介绍两种最常见冲突的解决方式</p>
<h2 id="svn_local_delete,_incoming_delete_upon_update的解决方式">svn local delete, incomin]]>
    </summary>
    
      <category term="版本控制" scheme="http://jatwaston.github.io/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="svn &amp; git" scheme="http://jatwaston.github.io/categories/svn-git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[UISearchDisplayController的用法]]></title>
    <link href="http://jatwaston.github.io/2015/04/01/uisearchdisplay/"/>
    <id>http://jatwaston.github.io/2015/04/01/uisearchdisplay/</id>
    <published>2015-04-01T01:33:48.000Z</published>
    <updated>2015-04-03T03:23:51.000Z</updated>
    <content type="html"><![CDATA[<p>稍候编辑1</p>
<a id="more"></a>
]]></content>
    <summary type="html">
    <![CDATA[<p>稍候编辑1</p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://jatwaston.github.io/tags/iOS/"/>
    
      <category term="iOS开发" scheme="http://jatwaston.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac下显示隐藏文件]]></title>
    <link href="http://jatwaston.github.io/2015/03/31/new-post/"/>
    <id>http://jatwaston.github.io/2015/03/31/new-post/</id>
    <published>2015-03-31T08:02:14.000Z</published>
    <updated>2015-04-01T01:41:53.000Z</updated>
    <content type="html"><![CDATA[<p>在终端输入以下代码:</p>
<p>显示的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.finder AppleShowAllFiles -<span class="keyword">bool</span> <span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<p>隐藏的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.finder AppleShowAllFiles -<span class="keyword">bool</span> <span class="keyword">false</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>在终端输入以下代码:</p>
<p>显示的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td]]>
    </summary>
    
      <category term="Mac" scheme="http://jatwaston.github.io/tags/Mac/"/>
    
      <category term="Mac Tips" scheme="http://jatwaston.github.io/categories/Mac-Tips/"/>
    
  </entry>
  
</feed>